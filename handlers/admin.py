from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from config import Config
from helpers.database import Database
from helpers.utils import humanbytes
import os
import sys
import asyncio
import subprocess

db = Database()

def admin_filter(func):
    """Decorator to check if user is admin"""
    async def wrapper(client, message):
        if message.from_user.id not in Config.ADMIN_ID:
            await message.reply_text("‚õî **A·¥Ñ·¥Ñ·¥áss D·¥á…¥…™·¥á·¥Ö!**\n\nThis command is only for administrators.")
            return
        return await func(client, message)
    return wrapper

# Restart Command
@Client.on_message(filters.command("restart") & filters.private)
@admin_filter
async def restart_handler(client, message: Message):
    msg = await message.reply_text("üîÑ **R·¥ás·¥õ·¥Ä Ä·¥õ…™…¥…¢...**")
    await msg.edit_text("‚úÖ **B·¥è·¥õ R·¥ás·¥õ·¥Ä Ä·¥õ·¥á·¥Ö S·¥ú·¥Ñ·¥Ñ·¥áss“ì·¥ú ü ü è!**")
    os.execl(sys.executable, sys.executable, *sys.argv)

# Queue Management
@Client.on_message(filters.command("queue") & filters.private)
@admin_filter
async def queue_handler(client, message: Message):
    from bot import encoding_queue, active_processes
    
    queue_size = encoding_queue.qsize()
    active_count = len(active_processes)
    
    text = f"""
üìä **Q·¥ú·¥á·¥ú·¥á S·¥õ·¥Ä·¥õ·¥ús**

üìù **P·¥á…¥·¥Ö…™…¥…¢ T·¥Äs·¥ãs:** {queue_size}
‚öôÔ∏è **A·¥Ñ·¥õ…™·¥†·¥á T·¥Äs·¥ãs:** {active_count}
"""
    
    if active_processes:
        text += "\n**A·¥Ñ·¥õ…™·¥†·¥á Us·¥á Äs:**\n"
        for user_id in active_processes.keys():
            text += f"‚Ä¢ User ID: `{user_id}`\n"
    
    await message.reply_text(text)

@Client.on_message(filters.command("clear") & filters.private)
@admin_filter
async def clear_queue_handler(client, message: Message):
    from bot import encoding_queue, active_processes
    
    # Clear queue
    while not encoding_queue.empty():
        try:
            encoding_queue.get_nowait()
        except:
            break
    
    # Clear active processes
    active_processes.clear()
    
    await message.reply_text("‚úÖ **Q·¥ú·¥á·¥ú·¥á C ü·¥á·¥Ä Ä·¥á·¥Ö!**")

# Settings Commands
@Client.on_message(filters.command("audio") & filters.private)
@admin_filter
async def audio_bitrate_handler(client, message: Message):
    if len(message.command) < 2:
        settings = await db.get_bot_settings()
        await message.reply_text(
            f"üîä **C·¥ú Ä Ä·¥á…¥·¥õ A·¥ú·¥Ö…™·¥è B…™·¥õ Ä·¥Ä·¥õ·¥á:** `{settings.get('audio_bitrate', '128k')}`\n\n"
            f"**Us·¥Ä…¢·¥á:** `/audio <bitrate>`\n"
            f"**Ex·¥Ä·¥ç·¥ò ü·¥á:** `/audio 192k`"
        )
        return
    
    bitrate = message.command[1]
    await db.update_bot_settings({'audio_bitrate': bitrate})
    await message.reply_text(f"‚úÖ **A·¥ú·¥Ö…™·¥è  ô…™·¥õ Ä·¥Ä·¥õ·¥á s·¥á·¥õ ·¥õ·¥è:** `{bitrate}`")

@Client.on_message(filters.command("codec") & filters.private)
@admin_filter
async def codec_handler(client, message: Message):
    if len(message.command) < 2:
        settings = await db.get_bot_settings()
        await message.reply_text(
            f"üé¨ **C·¥ú Ä Ä·¥á…¥·¥õ V…™·¥Ö·¥á·¥è C·¥è·¥Ö·¥á·¥Ñ:** `{settings.get('video_codec', 'libx264')}`\n\n"
            f"**Us·¥Ä…¢·¥á:** `/codec <codec_name>`\n"
            f"**Ex·¥Ä·¥ç·¥ò ü·¥á:** `/codec libx265`\n\n"
            f"**A·¥†·¥Ä…™ ü·¥Ä ô ü·¥á C·¥è·¥Ö·¥á·¥Ñs:**\n"
            f"‚Ä¢ libx264 (H.264)\n"
            f"‚Ä¢ libx265 (H.265/HEVC)\n"
            f"‚Ä¢ libvpx-vp9 (VP9)"
        )
        return
    
    codec = message.command[1]
    await db.update_bot_settings({'video_codec': codec})
    await message.reply_text(f"‚úÖ **V…™·¥Ö·¥á·¥è ·¥Ñ·¥è·¥Ö·¥á·¥Ñ s·¥á·¥õ ·¥õ·¥è:** `{codec}`")

@Client.on_message(filters.command("preset") & filters.private)
@admin_filter
async def preset_handler(client, message: Message):
    if len(message.command) < 2:
        settings = await db.get_bot_settings()
        await message.reply_text(
            f"‚öôÔ∏è **C·¥ú Ä Ä·¥á…¥·¥õ P Ä·¥ás·¥á·¥õ:** `{settings.get('preset', 'medium')}`\n\n"
            f"**Us·¥Ä…¢·¥á:** `/preset <preset_name>`\n\n"
            f"**A·¥†·¥Ä…™ ü·¥Ä ô ü·¥á P Ä·¥ás·¥á·¥õs:**\n"
            f"‚Ä¢ ultrafast (Fastest, lowest quality)\n"
            f"‚Ä¢ superfast\n"
            f"‚Ä¢ veryfast\n"
            f"‚Ä¢ faster\n"
            f"‚Ä¢ fast\n"
            f"‚Ä¢ medium (Balanced) ‚≠ê\n"
            f"‚Ä¢ slow\n"
            f"‚Ä¢ slower\n"
            f"‚Ä¢ veryslow (Slowest, best quality)"
        )
        return
    
    preset = message.command[1]
    valid_presets = ['ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow']
    
    if preset not in valid_presets:
        await message.reply_text("‚ö†Ô∏è **Invalid preset!** Choose from: " + ", ".join(valid_presets))
        return
    
    await db.update_bot_settings({'preset': preset})
    await message.reply_text(f"‚úÖ **P Ä·¥ás·¥á·¥õ s·¥á·¥õ ·¥õ·¥è:** `{preset}`")

@Client.on_message(filters.command("crf") & filters.private)
@admin_filter
async def crf_handler(client, message: Message):
    if len(message.command) < 2:
        settings = await db.get_bot_settings()
        await message.reply_text(
            f"üéØ **C·¥ú Ä Ä·¥á…¥·¥õ CRF V·¥Ä ü·¥ú·¥á:** `{settings.get('crf', 28)}`\n\n"
            f"**Us·¥Ä…¢·¥á:** `/crf <value>`\n"
            f"**R·¥Ä…¥…¢·¥á:** 0-51\n"
            f"**R·¥á·¥Ñ·¥è·¥ç·¥ç·¥á…¥·¥Ö·¥á·¥Ö:** 18-28\n\n"
            f"‚Ä¢ Lower value = Better quality, larger size\n"
            f"‚Ä¢ Higher value = Lower quality, smaller size"
        )
        return
    
    try:
        crf = int(message.command[1])
        if crf < 0 or crf > 51:
            await message.reply_text("‚ö†Ô∏è **CRF value must be between 0-51!**")
            return
        
        await db.update_bot_settings({'crf': crf})
        await message.reply_text(f"‚úÖ **CRF ·¥†·¥Ä ü·¥ú·¥á s·¥á·¥õ ·¥õ·¥è:** `{crf}`")
    except ValueError:
        await message.reply_text("‚ö†Ô∏è **Invalid CRF value! Must be a number.**")

# Force Subscription Management
@Client.on_message(filters.command("addchnl") & filters.private)
@admin_filter
async def add_fsub_channel(client, message: Message):
    if len(message.command) < 2:
        await message.reply_text(
            "**Us·¥Ä…¢·¥á:** `/addchnl <channel_id>`\n"
            "**Ex·¥Ä·¥ç·¥ò ü·¥á:** `/addchnl -1001234567890`"
        )
        return
    
    try:
        channel_id = int(message.command[1])
        await db.add_fsub_channel(channel_id)
        await message.reply_text(f"‚úÖ **C ú·¥Ä…¥…¥·¥á ü ·¥Ä·¥Ö·¥Ö·¥á·¥Ö ·¥õ·¥è “ìs·¥ú ô!**\n\nChannel ID: `{channel_id}`")
    except ValueError:
        await message.reply_text("‚ö†Ô∏è **Invalid channel ID!**")

@Client.on_message(filters.command("delchnl") & filters.private)
@admin_filter
async def del_fsub_channel(client, message: Message):
    if len(message.command) < 2:
        await message.reply_text(
            "**Us·¥Ä…¢·¥á:** `/delchnl <channel_id>`\n"
            "**Ex·¥Ä·¥ç·¥ò ü·¥á:** `/delchnl -1001234567890`"
        )
        return
    
    try:
        channel_id = int(message.command[1])
        await db.remove_fsub_channel(channel_id)
        await message.reply_text(f"‚úÖ **C ú·¥Ä…¥…¥·¥á ü  Ä·¥á·¥ç·¥è·¥†·¥á·¥Ö “ì Ä·¥è·¥ç “ìs·¥ú ô!**\n\nChannel ID: `{channel_id}`")
    except ValueError:
        await message.reply_text("‚ö†Ô∏è **Invalid channel ID!**")

@Client.on_message(filters.command("listchnl") & filters.private)
@admin_filter
async def list_fsub_channels(client, message: Message):
    channels = await db.get_fsub_channels()
    
    if not channels:
        await message.reply_text("üìù **N·¥è “ìs·¥ú ô ·¥Ñ ú·¥Ä…¥…¥·¥á üs ·¥Ñ·¥è…¥“ì…™…¢·¥ú Ä·¥á·¥Ö!**")
        return
    
    text = "üì¢ **Fs·¥ú ô C ú·¥Ä…¥…¥·¥á üs:**\n\n"
    for channel_id in channels:
        try:
            chat = await client.get_chat(channel_id)
            text += f"‚Ä¢ {chat.title} (`{channel_id}`)\n"
        except:
            text += f"‚Ä¢ Channel ID: `{channel_id}`\n"
    
    await message.reply_text(text)

# Premium User Management
@Client.on_message(filters.command("addpaid") & filters.private)
@admin_filter
async def add_premium_user(client, message: Message):
    if len(message.command) < 2:
        await message.reply_text(
            "**Us·¥Ä…¢·¥á:** `/addpaid <user_id> [days]`\n"
            "**Ex·¥Ä·¥ç·¥ò ü·¥á:** `/addpaid 123456789 30`\n"
            "**D·¥á“ì·¥Ä·¥ú ü·¥õ:** 30 days"
        )
        return
    
    try:
        user_id = int(message.command[1])
        days = int(message.command[2]) if len(message.command) > 2 else 30
        
        await db.add_premium_user(user_id, days)
        await message.reply_text(
            f"‚úÖ **P Ä·¥á·¥ç…™·¥ú·¥ç ·¥Ä·¥Ñ·¥Ñ·¥áss …¢ Ä·¥Ä…¥·¥õ·¥á·¥Ö!**\n\n"
            f"**Us·¥á Ä ID:** `{user_id}`\n"
            f"**D·¥ú Ä·¥Ä·¥õ…™·¥è…¥:** {days} days"
        )
    except ValueError:
        await message.reply_text("‚ö†Ô∏è **Invalid user ID or days!**")

@Client.on_message(filters.command("rempaid") & filters.private)
@admin_filter
async def remove_premium_user(client, message: Message):
    if len(message.command) < 2:
        await message.reply_text(
            "**Us·¥Ä…¢·¥á:** `/rempaid <user_id>`\n"
            "**Ex·¥Ä·¥ç·¥ò ü·¥á:** `/rempaid 123456789`"
        )
        return
    
    try:
        user_id = int(message.command[1])
        await db.remove_premium_user(user_id)
        await message.reply_text(f"‚úÖ **P Ä·¥á·¥ç…™·¥ú·¥ç ·¥Ä·¥Ñ·¥Ñ·¥áss  Ä·¥á·¥ç·¥è·¥†·¥á·¥Ö!**\n\nUser ID: `{user_id}`")
    except ValueError:
        await message.reply_text("‚ö†Ô∏è **Invalid user ID!**")

@Client.on_message(filters.command("listpaid") & filters.private)
@admin_filter
async def list_premium_users(client, message: Message):
    premium_users = await db.get_premium_users()
    
    text = "üíé **P Ä·¥á·¥ç…™·¥ú·¥ç Us·¥á Äs:**\n\n"
    count = 0
    
    async for user in premium_users:
        count += 1
        expire = user['expire_date'].strftime("%Y-%m-%d")
        text += f"{count}. User ID: `{user['user_id']}`\n   Expires: {expire}\n\n"
    
    if count == 0:
        text = "üíé **N·¥è ·¥ò Ä·¥á·¥ç…™·¥ú·¥ç ·¥ús·¥á Äs!**"
    
    await message.reply_text(text)

# Update Command
@Client.on_message(filters.command("update") & filters.private)
@admin_filter
async def update_handler(client, message: Message):
    msg = await message.reply_text("üîÑ **C ú·¥á·¥Ñ·¥ã…™…¥…¢ “ì·¥è Ä ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥ás...**")
    
    try:
        result = subprocess.run(
            ['git', 'pull'],
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0:
            output = result.stdout
            if "Already up to date" in output:
                await msg.edit_text("‚úÖ **B·¥è·¥õ …™s ·¥Ä ü Ä·¥á·¥Ä·¥Ö è ·¥ú·¥ò ·¥õ·¥è ·¥Ö·¥Ä·¥õ·¥á!**")
            else:
                await msg.edit_text(f"‚úÖ **U·¥ò·¥Ö·¥Ä·¥õ·¥á·¥Ö s·¥ú·¥Ñ·¥Ñ·¥áss“ì·¥ú ü ü è!**\n\n```\n{output}\n```\n\nRestarting...")
                os.execl(sys.executable, sys.executable, *sys.argv)
        else:
            await msg.edit_text(f"‚ùå **U·¥ò·¥Ö·¥Ä·¥õ·¥á “ì·¥Ä…™ ü·¥á·¥Ö!**\n\n```\n{result.stderr}\n```")
    except Exception as e:
        await msg.edit_text(f"‚ùå **E Ä Ä·¥è Ä:** `{str(e)}`")

# Statistics
@Client.on_message(filters.command("stats") & filters.private)
@admin_filter
async def stats_handler(client, message: Message):
    total_users = await db.total_users_count()
    premium_users = await db.get_premium_user_count()
    total_encodes = await db.get_total_encodes()
    
    text = f"""
üìä **B·¥è·¥õ S·¥õ·¥Ä·¥õ…™s·¥õ…™·¥Ñs**

üë• **T·¥è·¥õ·¥Ä ü Us·¥á Äs:** {total_users}
üíé **P Ä·¥á·¥ç…™·¥ú·¥ç Us·¥á Äs:** {premium_users}
üé¨ **T·¥è·¥õ·¥Ä ü E…¥·¥Ñ·¥è·¥Ö·¥ás:** {total_encodes}
"""
    
    await message.reply_text(text)

# Broadcast
@Client.on_message(filters.command("broadcast") & filters.private)
@admin_filter
async def broadcast_handler(client, message: Message):
    if message.reply_to_message:
        msg = await message.reply_text("üì¢ **B Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ…™…¥…¢...**")
        
        users = await db.get_all_users()
        success = 0
        failed = 0
        
        async for user in users:
            try:
                await message.reply_to_message.copy(user['user_id'])
                success += 1
            except:
                failed += 1
            
            if (success + failed) % 20 == 0:
                await msg.edit_text(
                    f"üì¢ **B Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ…™…¥…¢...**\n\n"
                    f"‚úÖ Success: {success}\n"
                    f"‚ùå Failed: {failed}"
                )
        
        await msg.edit_text(
            f"‚úÖ **B Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ C·¥è·¥ç·¥ò ü·¥á·¥õ·¥á·¥Ö!**\n\n"
            f"‚úÖ Success: {success}\n"
            f"‚ùå Failed: {failed}"
        )
    else:
        await message.reply_text("‚ö†Ô∏è **Reply to a message to broadcast it!**")
